<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini WorldBox ¬∑ Simulador de Dios</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        body {
            background: #1a2a32;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            margin: 0;
            padding: 16px;
        }
        .game-container {
            background: #2a3f4a;
            border-radius: 28px;
            padding: 24px;
            box-shadow: 0 20px 30px rgba(0,0,0,0.6);
        }
        .canvas-wrapper {
            display: flex;
            justify-content: center;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: inset 0 0 0 2px #1e2f38, 0 10px 15px -5px #0f1a1f;
        }
        canvas {
            display: block;
            width: 600px;
            height: 600px;
            background: #2d4d3a;
            cursor: crosshair;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        button {
            background: #3e5a66;
            border: none;
            border-radius: 40px;
            padding: 10px 20px;
            font-weight: bold;
            font-size: 16px;
            color: white;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 5px 0 #1e2f38, 0 8px 12px rgba(0,0,0,0.4);
            cursor: pointer;
            transition: 0.07s ease;
            border: 1px solid #6b8b9c;
        }
        button:active {
            transform: translateY(5px);
            box-shadow: 0 2px 0 #1e2f38, 0 5px 10px rgba(0,0,0,0.4);
        }
        .brush-indicator {
            background: #263b45;
            border-radius: 40px;
            padding: 8px 18px;
            color: #c3e2f0;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: inset 0 2px 5px #0f1f27;
        }
        .color-dot {
            width: 24px;
            height: 24px;
            border-radius: 24px;
            border: 2px solid white;
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 16px;
            background: #1f333c;
            border-radius: 40px;
            padding: 8px 20px;
            color: #bcdae8;
            font-weight: 500;
        }
        .footer-note {
            color: #7f9faa;
            text-align: center;
            margin-top: 12px;
            font-size: 14px;
        }
        .btn-special {
            background: #6a4e3a;
            border-color: #b98f6b;
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="canvas-wrapper">
        <canvas id="worldCanvas" width="600" height="600"></canvas>
    </div>

    <div class="toolbar">
        <button id="btnGrass" style="background:#5b8c5a;">üåø Tierra</button>
        <button id="btnTree" style="background:#2d6a4f;">üå≤ √Årbol</button>
        <button id="btnWater" style="background:#2c7da0;">üíß Agua</button>
        <button id="btnFire" style="background:#d45d2e;">üî• Fuego</button>
        <button id="btnEraser" style="background:#6b6b6b;">‚å´ Borrar</button>
        <button id="btnRandom" class="btn-special">üé≤ Aleatorio</button>
        <button id="btnClear" style="background:#4f5f6e;">üóëÔ∏è Limpiar</button>
    </div>

    <div class="toolbar">
        <button id="btnPlayPause" style="background:#3f7e6b; min-width: 120px;">‚è∏Ô∏è Pausa</button>
        <button id="btnStep" style="background:#5d6174;">‚è© Un paso</button>
        <div class="brush-indicator">
            <span>Pincel:</span>
            <span id="brushName">Tierra</span>
            <span class="color-dot" id="brushColor" style="background:#5b8c5a;"></span>
        </div>
    </div>

    <div class="status-bar">
        <span>üå≥ <span id="treeCount">0</span></span>
        <span>üî• <span id="fireCount">0</span></span>
        <span>üíß <span id="waterCount">0</span></span>
        <span>üåø <span id="grassCount">0</span></span>
    </div>
    <div class="footer-note">
        ‚ö° Click izquierdo: pintar ¬∑ Click derecho: borrar ¬∑ Los elementos interact√∫an
    </div>
</div>

<script>
    (function() {
        // ---------- CONSTANTES Y CONFIG ----------
        const GRID_SIZE = 40;              // 40x40 celdas
        const CELL_SIZE = 15;               // p√≠xeles por celda
        const TYPES = {
            VACIO: 0,
            GRASS: 1,
            TREE: 2,
            WATER: 3,
            FIRE: 4
        };
        const TYPE_NAMES = ['Vac√≠o', 'Tierra', '√Årbol', 'Agua', 'Fuego'];
        const TYPE_COLORS = [
            '#3d5a4b',   // vac√≠o / gris oscuro (fondo base)
            '#5b8c5a',   // grass / tierra
            '#2d6a4f',   // √°rbol
            '#2c7da0',   // agua
            '#d45d2e'    // fuego
        ];

        // ---------- ESTADO GLOBAL ----------
        let grid = [];                     // matriz 2D [fila][col]
        let selectedBrush = TYPES.GRASS;    // pincel inicial: tierra
        let painting = false;               // si el mouse est√° presionando
        let simulationInterval = null;
        let simulationRunning = false;       // arranca pausado (lo ponemos en true tras init para que corra)
        const canvas = document.getElementById('worldCanvas');
        const ctx = canvas.getContext('2d');

        // elementos UI
        const brushNameSpan = document.getElementById('brushName');
        const brushColorDiv = document.getElementById('brushColor');
        const treeCountSpan = document.getElementById('treeCount');
        const fireCountSpan = document.getElementById('fireCount');
        const waterCountSpan = document.getElementById('waterCount');
        const grassCountSpan = document.getElementById('grassCount');
        const playPauseBtn = document.getElementById('btnPlayPause');

        // ---------- INICIALIZAR GRID (mundo) ----------
        function initGrid() {
            grid = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                const fila = [];
                for (let col = 0; col < GRID_SIZE; col++) {
                    // empezamos con tierra, algunos √°rboles y algo de agua
                    let rand = Math.random();
                    if (rand < 0.1) {
                        fila.push(TYPES.WATER);
                    } else if (rand < 0.25) {
                        fila.push(TYPES.TREE);
                    } else {
                        fila.push(TYPES.GRASS);
                    }
                }
                grid.push(fila);
            }
        }

        // ---------- DIBUJAR EL MUNDO ----------
        function drawGrid() {
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const type = grid[row][col];
                    ctx.fillStyle = TYPE_COLORS[type];
                    ctx.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE-0.5, CELL_SIZE-0.5);
                }
            }
            // peque√±as l√≠neas de separaci√≥n (opcional, da sensaci√≥n de rejilla)
            ctx.strokeStyle = '#1e3b2b';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.strokeStyle = '#2b4a37';
                ctx.lineWidth = 0.4;
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }

            // actualizar contadores
            updateCounts();
        }

        // ---------- CONTADORES ESTAD√çSTICOS ----------
        function updateCounts() {
            let trees = 0, fires = 0, waters = 0, grasses = 0;
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const val = grid[row][col];
                    if (val === TYPES.TREE) trees++;
                    else if (val === TYPES.FIRE) fires++;
                    else if (val === TYPES.WATER) waters++;
                    else if (val === TYPES.GRASS) grasses++;
                }
            }
            treeCountSpan.innerText = trees;
            fireCountSpan.innerText = fires;
            waterCountSpan.innerText = waters;
            grassCountSpan.innerText = grasses;
        }

        // ---------- SIMULACI√ìN (REGLAS) ----------
        function nextGeneration() {
            const newGrid = JSON.parse(JSON.stringify(grid)); // copia profunda

            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const cell = grid[row][col];

                    // Reglas para cada tipo (basadas en el grid actual)
                    if (cell === TYPES.TREE) {
                        // Si alg√∫n vecino es fuego, el √°rbol puede incendiarse
                        if (hasNeighbor(row, col, TYPES.FIRE)) {
                            if (Math.random() < 0.35) { // probabilidad de prender
                                newGrid[row][col] = TYPES.FIRE;
                            }
                        }
                    }
                    else if (cell === TYPES.GRASS) {
                        // El pasto puede incendiarse si hay fuego cerca
                        if (hasNeighbor(row, col, TYPES.FIRE)) {
                            if (Math.random() < 0.25) {
                                newGrid[row][col] = TYPES.FIRE;
                            }
                        }
                    }
                    else if (cell === TYPES.FIRE) {
                        // El fuego se apaga si toca agua, o se extingue solo aleatoriamente
                        if (hasNeighbor(row, col, TYPES.WATER)) {
                            newGrid[row][col] = TYPES.GRASS; // se apaga y deja tierra
                        } else if (Math.random() < 0.1) {
                            newGrid[row][col] = TYPES.GRASS; // se apaga solo
                        } else {
                            // permanece fuego
                            newGrid[row][col] = TYPES.FIRE;
                        }
                    }
                    // Agua y vac√≠o no cambian (por ahora)
                }
            }
            grid = newGrid;
            drawGrid();
        }

        // Util: comprueba si en las 8 celdas vecinas hay un tipo dado (o 4 direcciones? pondremos 8 para m√°s interacci√≥n)
        function hasNeighbor(row, col, type) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = row + dr;
                    const nc = col + dc;
                    if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                        if (grid[nr][nc] === type) return true;
                    }
                }
            }
            return false;
        }

        // ---------- CONTROL DE SIMULACI√ìN ----------
        function startSimulation() {
            if (simulationInterval) return;
            simulationRunning = true;
            playPauseBtn.innerHTML = '‚è∏Ô∏è Pausa';
            simulationInterval = setInterval(() => {
                nextGeneration();
            }, 150); // velocidad agradable
        }

        function stopSimulation() {
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
            }
            simulationRunning = false;
            playPauseBtn.innerHTML = '‚ñ∂Ô∏è Iniciar';
        }

        function toggleSimulation() {
            if (simulationRunning) {
                stopSimulation();
            } else {
                startSimulation();
            }
        }

        // ---------- PINTAR CON MOUSE ----------
        function getCellFromCoord(coord, maxIndex) {
            return Math.floor(coord / CELL_SIZE);
        }

        function handlePaint(col, row, brush) {
            if (row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE) return;
            grid[row][col] = brush;
            drawGrid();
        }

        // Eventos de mouse
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            const col = getCellFromCoord(mouseX, GRID_SIZE);
            const row = getCellFromCoord(mouseY, GRID_SIZE);

            if (e.button === 0) { // izquierdo: pincel actual
                painting = true;
                handlePaint(col, row, selectedBrush);
            } else if (e.button === 2) { // derecho: borrar (vac√≠o)
                painting = true;
                handlePaint(col, row, TYPES.VACIO);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!painting) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            const col = getCellFromCoord(mouseX, GRID_SIZE);
            const row = getCellFromCoord(mouseY, GRID_SIZE);

            if (e.buttons === 1) { // izquierdo
                handlePaint(col, row, selectedBrush);
            } else if (e.buttons === 2) { // derecho
                handlePaint(col, row, TYPES.VACIO);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            painting = false;
        });

        canvas.addEventListener('mouseleave', () => {
            painting = false;
        });

        // Desactivar men√∫ contextual en el canvas (para usar bot√≥n derecho)
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // ---------- BOTONES DE HERRAMIENTAS ----------
        document.getElementById('btnGrass').addEventListener('click', () => {
            selectedBrush = TYPES.GRASS;
            brushNameSpan.innerText = 'Tierra';
            brushColorDiv.style.background = TYPE_COLORS[TYPES.GRASS];
        });
        document.getElementById('btnTree').addEventListener('click', () => {
            selectedBrush = TYPES.TREE;
            brushNameSpan.innerText = '√Årbol';
            brushColorDiv.style.background = TYPE_COLORS[TYPES.TREE];
        });
        document.getElementById('btnWater').addEventListener('click', () => {
            selectedBrush = TYPES.WATER;
            brushNameSpan.innerText = 'Agua';
            brushColorDiv.style.background = TYPE_COLORS[TYPES.WATER];
        });
        document.getElementById('btnFire').addEventListener('click', () => {
            selectedBrush = TYPES.FIRE;
            brushNameSpan.innerText = 'Fuego';
            brushColorDiv.style.background = TYPE_COLORS[TYPES.FIRE];
        });
        document.getElementById('btnEraser').addEventListener('click', () => {
            selectedBrush = TYPES.VACIO;
            brushNameSpan.innerText = 'Borrar';
            brushColorDiv.style.background = TYPE_COLORS[TYPES.VACIO];
        });

        // Bot√≥n aleatorio: llena de tipos aleatorios con m√°s vegetaci√≥n
        document.getElementById('btnRandom').addEventListener('click', () => {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const rand = Math.random();
                    if (rand < 0.1) grid[r][c] = TYPES.WATER;
                    else if (rand < 0.3) grid[r][c] = TYPES.TREE;
                    else if (rand < 0.4) grid[r][c] = TYPES.FIRE;
                    else grid[r][c] = TYPES.GRASS;
                }
            }
            drawGrid();
        });

        // Bot√≥n limpiar: todo tierra (vac√≠o no, para que no quede gris)
        document.getElementById('btnClear').addEventListener('click', () => {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    grid[r][c] = TYPES.GRASS;
                }
            }
            drawGrid();
        });

        // Bot√≥n play/pausa
        playPauseBtn.addEventListener('click', toggleSimulation);

        // Bot√≥n paso a paso (avanza una generaci√≥n aunque est√© pausado)
        document.getElementById('btnStep').addEventListener('click', () => {
            if (simulationRunning) {
                // si est√° corriendo, no interrumpimos, pero ejecutamos un extra
                nextGeneration();
            } else {
                nextGeneration();
            }
        });

        // ---------- INICIALIZAR TODO Y EMPEZAR SIMULACI√ìN ----------
        initGrid();
        drawGrid();
        // Iniciamos la simulaci√≥n autom√°ticamente (como en WorldBox)
        startSimulation();

        // Ajustar nombre del pincel inicial
        brushNameSpan.innerText = 'Tierra';
        brushColorDiv.style.background = TYPE_COLORS[TYPES.GRASS];
    })();
</script>
</body>
</html>
