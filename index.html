<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Mini WorldBox Clone</title>
    <style>
        body { background: #222; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        canvas { border: 4px solid #444; background: #000; cursor: crosshair; image-rendering: pixelated; }
        .controls { margin: 10px; display: flex; gap: 10px; }
        button { padding: 10px; cursor: pointer; border: none; border-radius: 5px; font-weight: bold; }
        .btn-land { background: #3a5f0b; color: white; }
        .btn-water { background: #0b5f5f; color: white; }
        .btn-human { background: #d2b48c; color: black; }
        .btn-spawn { background: #ffcc00; }
    </style>
</head>
<body>

    <h2>Simulador de Dios HTML5</h2>
    <div class="controls">
        <button class="btn-land" onclick="setTool('land')">Tierra</button>
        <button class="btn-water" onclick="setTool('water')">Agua</button>
        <button class="btn-human" onclick="setTool('human')">Crear Humano</button>
        <button class="btn-spawn" onclick="generateMap()">Regenerar Mundo</button>
    </div>
    <canvas id="worldCanvas" width="600" height="400"></canvas>

<script>
    const canvas = document.getElementById('worldCanvas');
    const ctx = canvas.getContext('2d');
    const cellSize = 10;
    const rows = canvas.height / cellSize;
    const cols = canvas.width / cellSize;

    let world = [];
    let entities = [];
    let currentTool = 'land';

    // Tipos de terreno
    const TERRAIN = {
        WATER: { color: '#1e90ff', id: 0 },
        SAND: { color: '#f0e68c', id: 1 },
        GRASS: { color: '#228b22', id: 2 }
    };

    function init() {
        generateMap();
        setInterval(update, 200); // 5 frames por segundo para estilo retro
    }

    function generateMap() {
        world = [];
        entities = [];
        for (let r = 0; r < rows; r++) {
            world[r] = [];
            for (let c = 0; c < cols; c++) {
                // Generación aleatoria simple (luego puedes usar Perlin Noise)
                world[r][c] = Math.random() > 0.1 ? TERRAIN.WATER : TERRAIN.SAND;
            }
        }
        draw();
    }

    function setTool(tool) { currentTool = tool; }

    // Interacción con el ratón
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / cellSize);
        const y = Math.floor((e.clientY - rect.top) / cellSize);

        if (currentTool === 'land') world[y][x] = TERRAIN.GRASS;
        if (currentTool === 'water') world[y][x] = TERRAIN.WATER;
        if (currentTool === 'human') entities.push({ x, y, color: '#ffdbac', hunger: 100 });
        
        draw();
    });

    function update() {
        // Simulación: La hierba se expande cerca del agua
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (world[r][c] === TERRAIN.SAND && Math.random() > 0.98) {
                    world[r][c] = TERRAIN.GRASS;
                }
            }
        }

        // IA Básica de humanos
        entities.forEach(h => {
            h.x += Math.floor(Math.random() * 3) - 1;
            h.y += Math.floor(Math.random() * 3) - 1;
            // Mantener dentro de los límites
            h.x = Math.max(0, Math.min(cols - 1, h.x));
            h.y = Math.max(0, Math.min(rows - 1, h.y));
        });

        draw();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Dibujar Terreno
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                ctx.fillStyle = world[r][c].color;
                ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
            }
        }

        // Dibujar Entidades (Humanos)
        entities.forEach(h => {
            ctx.fillStyle = h.color;
            ctx.fillRect(h.x * cellSize + 2, h.y * cellSize + 2, cellSize - 4, cellSize - 4);
        });
    }

    init();
</script>
</body>
</html>
