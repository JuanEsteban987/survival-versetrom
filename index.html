<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft P2P Pixel Art (Hotbar y colocación corregidas)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', monospace; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 100;
            pointer-events: none;
        }
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
            z-index: 200;
            pointer-events: auto;
        }
        .slot {
            width: 60px;
            height: 60px;
            background: #8b8b8b;
            border: 3px solid #555;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            text-shadow: 1px 1px 0 #000;
            font-size: 12px;
            transition: 0.2s;
            image-rendering: pixelated;
        }
        .slot.selected {
            border-color: #ffaa00;
            transform: scale(1.1);
        }
        .slot canvas {
            width: 40px;
            height: 40px;
            image-rendering: pixelated;
        }
        #pixel-editor {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #333;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #fff;
            z-index: 300;
            display: none;
            color: white;
            text-align: center;
        }
        #pixel-grid {
            display: grid;
            grid-template-columns: repeat(16, 20px);
            gap: 1px;
            margin: 10px 0;
            background: #222;
            padding: 5px;
        }
        .pixel-cell {
            width: 20px;
            height: 20px;
            background: #fff;
            cursor: pointer;
            image-rendering: pixelated;
        }
        #color-palette {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin: 10px 0;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid #fff;
        }
        #peer-section {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
        }
        #peer-section input, #peer-section button {
            padding: 5px;
            font-family: inherit;
        }
        #status {
            color: #0f0;
            font-size: 12px;
        }
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 8px 12px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: #45a049;
        }
    </style>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
    <div id="info">
        <div>Romper: Click izquierdo | Poner: Click derecho</div>
        <div>Movimiento: WASD | Saltar: Espacio | Mirar: Mouse</div>
        <div>Pixel art: Botón "Editor"</div>
    </div>
    <div id="controls">Bloque seleccionado: <span id="selected-block-name">Grass</span></div>
    <div id="hotbar"></div>
    <div id="peer-section">
        <div>Mi ID: <span id="my-id">conectando...</span></div>
        <input type="text" id="peer-id-input" placeholder="ID del peer">
        <button id="connect-btn">Conectar</button>
        <button id="editor-btn">Editor Pixel Art</button>
        <div id="status">Desconectado</div>
    </div>
    <div id="pixel-editor">
        <h3>Editor 16x16</h3>
        <div id="pixel-grid"></div>
        <div id="color-palette">
            <div class="color-option" style="background:#8B4513;"></div>
            <div class="color-option" style="background:#654321;"></div>
            <div class="color-option" style="background:#228B22;"></div>
            <div class="color-option" style="background:#FF0000;"></div>
            <div class="color-option" style="background:#0000FF;"></div>
            <div class="color-option" style="background:#FFFF00;"></div>
        </div>
        <div>
            <button id="save-pixel-btn">Guardar como bloque</button>
            <button id="close-editor-btn">Cerrar</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'https://unpkg.com/three@0.128.0/examples/jsm/controls/PointerLockControls.js';

        const Peer = window.Peer;

        // --- Configuración inicial ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.8, 5); // altura de ojos
        
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Luces
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
        backLight.position.set(-1, 0.5, -1);
        scene.add(backLight);

        // Controles primera persona (solo para mirar, movimiento manual)
        const controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        renderer.domElement.addEventListener('click', () => {
            if (!controls.isLocked) controls.lock();
        });

        // --- Variables de movimiento y física ---
        const moveState = { w: false, a: false, s: false, d: false, space: false };
        const velocity = new THREE.Vector3(0, 0, 0);
        const gravity = -12.0;
        const jumpSpeed = 5.0;
        const walkSpeed = 1.5; // más lento que antes
        const playerHeight = 1.8;
        const playerRadius = 0.3; // para colisiones

        let onGround = false;

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.w = true; e.preventDefault(); break;
                case 'KeyA': moveState.a = true; e.preventDefault(); break;
                case 'KeyS': moveState.s = true; e.preventDefault(); break;
                case 'KeyD': moveState.d = true; e.preventDefault(); break;
                case 'Space': moveState.space = true; e.preventDefault(); break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.w = false; e.preventDefault(); break;
                case 'KeyA': moveState.a = false; e.preventDefault(); break;
                case 'KeyS': moveState.s = false; e.preventDefault(); break;
                case 'KeyD': moveState.d = false; e.preventDefault(); break;
                case 'Space': moveState.space = false; e.preventDefault(); break;
            }
        });

        // --- Mundo de bloques ---
        const blockSize = 1;
        const blocks = new Map(); // clave "x,y,z" -> { type, mesh }

        function createPixelTexture(colors) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            for (let y = 0; y < 16; y++) {
                for (let x = 0; x < 16; x++) {
                    ctx.fillStyle = colors[y][x] || '#8B4513';
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            return new THREE.CanvasTexture(canvas);
        }

        function grassTexture() {
            const colors = Array(16).fill().map(() => Array(16).fill('#228B22'));
            for (let i = 0; i < 20; i++) {
                colors[Math.floor(Math.random()*16)][Math.floor(Math.random()*16)] = '#8B4513';
            }
            return createPixelTexture(colors);
        }

        function dirtTexture() {
            const colors = Array(16).fill().map(() => Array(16).fill('#8B4513'));
            return createPixelTexture(colors);
        }

        function stoneTexture() {
            const colors = Array(16).fill().map(() => Array(16).fill('#808080'));
            for (let i = 0; i < 30; i++) {
                colors[Math.floor(Math.random()*16)][Math.floor(Math.random()*16)] = '#A9A9A9';
            }
            return createPixelTexture(colors);
        }

        // Tipos de bloque
        const blockTypes = [
            { name: 'Grass', texture: grassTexture() },
            { name: 'Dirt', texture: dirtTexture() },
            { name: 'Stone', texture: stoneTexture() },
            { name: 'Custom', texture: grassTexture() } // se actualizará
        ];

        // Inventario: índices de blockTypes
        let inventory = [0, 1, 2, 3];
        let selectedSlot = 0;

        // --- Hotbar UI ---
        const hotbarDiv = document.getElementById('hotbar');
        const selectedNameSpan = document.getElementById('selected-block-name');

        function updateHotbar() {
            hotbarDiv.innerHTML = '';
            inventory.forEach((typeIdx, i) => {
                const slot = document.createElement('div');
                slot.className = 'slot' + (i === selectedSlot ? ' selected' : '');
                
                // Miniatura
                const canvas = document.createElement('canvas');
                canvas.width = 16;
                canvas.height = 16;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                const texture = blockTypes[typeIdx].texture;
                // La imagen puede no estar cargada instantáneamente, pero como es canvas sí
                ctx.drawImage(texture.image, 0, 0, 16, 16);
                slot.appendChild(canvas);
                
                const span = document.createElement('span');
                span.textContent = blockTypes[typeIdx].name;
                slot.appendChild(span);
                
                // Evento de selección
                slot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectedSlot = i;
                    updateHotbar();
                    selectedNameSpan.textContent = blockTypes[inventory[selectedSlot]].name;
                });
                
                hotbarDiv.appendChild(slot);
            });
        }
        updateHotbar();
        selectedNameSpan.textContent = blockTypes[inventory[selectedSlot]].name;

        // Funciones de bloques
        function addBlock(x, y, z, typeIndex) {
            const key = `${x},${y},${z}`;
            if (blocks.has(key)) return;
            
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const materials = [
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture })
            ];
            const cube = new THREE.Mesh(geometry, materials);
            cube.position.set(x, y, z);
            scene.add(cube);
            blocks.set(key, { type: typeIndex, mesh: cube });
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = blocks.get(key);
            if (block) {
                scene.remove(block.mesh);
                block.mesh.geometry.dispose();
                block.mesh.material.forEach(m => m.dispose());
                blocks.delete(key);
                return true;
            }
            return false;
        }

        // Suelo inicial (piso de grass)
        for (let x = -5; x < 5; x++) {
            for (let z = -5; z < 5; z++) {
                addBlock(x, 0, z, 0);
            }
        }
        // Algunos bloques de prueba
        addBlock(2, 1, 2, 1);
        addBlock(2, 2, 2, 2);
        addBlock(-2, 1, -2, 0);

        // --- Raycaster para interacción ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function getBlockAtCursor() {
            if (!controls.isLocked) return null;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(Array.from(blocks.values()).map(b => b.mesh));
            if (intersects.length > 0) {
                const hit = intersects[0];
                const pos = hit.object.position;
                return { 
                    pos: pos.clone(), 
                    face: hit.face.normal.clone(),
                    block: blocks.get(`${pos.x},${pos.y},${pos.z}`)
                };
            }
            return null;
        }

        // Eventos de clic
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (!controls.isLocked) return;
            e.preventDefault();
            const hit = getBlockAtCursor();
            if (!hit) return;

            if (e.button === 0) { // Izquierdo: romper
                removeBlock(hit.pos.x, hit.pos.y, hit.pos.z);
                sendToAll({ type: 'break', x: hit.pos.x, y: hit.pos.y, z: hit.pos.z });
            } else if (e.button === 2) { // Derecho: colocar
                e.preventDefault();
                const normal = hit.face;
                const newPos = hit.pos.clone().add(normal);
                // Redondear a coordenadas enteras por si acaso
                newPos.x = Math.round(newPos.x);
                newPos.y = Math.round(newPos.y);
                newPos.z = Math.round(newPos.z);
                
                if (!blocks.has(`${newPos.x},${newPos.y},${newPos.z}`)) {
                    const typeIdx = inventory[selectedSlot];
                    addBlock(newPos.x, newPos.y, newPos.z, typeIdx);
                    sendToAll({ type: 'place', x: newPos.x, y: newPos.y, z: newPos.z, blockType: typeIdx });
                }
            }
        });

        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Colisiones con bloques (detección simple) ---
        function collidesWithWorld(pos) {
            // Caja del jugador: desde pos.y - playerHeight/2 hasta pos.y + playerHeight/2? 
            // Mejor usar un punto central y comprobar bloques alrededor.
            // Usaremos un enfoque simple: comprobar si el bloque en (floor(x), floor(y), floor(z)) está ocupado,
            // pero el jugador tiene volumen. Para simplificar, comprobamos 8 esquinas de la caja.
            const playerMinX = pos.x - playerRadius;
            const playerMaxX = pos.x + playerRadius;
            const playerMinY = pos.y - playerHeight/2; // pies
            const playerMaxY = pos.y + playerHeight/2; // cabeza
            const playerMinZ = pos.z - playerRadius;
            const playerMaxZ = pos.z + playerRadius;

            // Rango de bloques a comprobar (enteros)
            const x0 = Math.floor(playerMinX);
            const x1 = Math.floor(playerMaxX);
            const y0 = Math.floor(playerMinY);
            const y1 = Math.floor(playerMaxY);
            const z0 = Math.floor(playerMinZ);
            const z1 = Math.floor(playerMaxZ);

            for (let ix = x0; ix <= x1; ix++) {
                for (let iy = y0; iy <= y1; iy++) {
                    for (let iz = z0; iz <= z1; iz++) {
                        if (blocks.has(`${ix},${iy},${iz}`)) {
                            // AABB del bloque
                            const blockMinX = ix;
                            const blockMaxX = ix + 1;
                            const blockMinY = iy;
                            const blockMaxY = iy + 1;
                            const blockMinZ = iz;
                            const blockMaxZ = iz + 1;

                            if (playerMaxX > blockMinX && playerMinX < blockMaxX &&
                                playerMaxY > blockMinY && playerMinY < blockMaxY &&
                                playerMaxZ > blockMinZ && playerMinZ < blockMaxZ) {
                                return true; // colisión
                            }
                        }
                    }
                }
            }
            return false;
        }

        // --- Pixel Art Editor ---
        const pixelEditor = document.getElementById('pixel-editor');
        const pixelGrid = document.getElementById('pixel-grid');
        let currentColor = '#8B4513';
        let pixelData = Array(16).fill().map(() => Array(16).fill('#FFFFFF'));

        function renderPixelGrid() {
            pixelGrid.innerHTML = '';
            for (let y = 0; y < 16; y++) {
                for (let x = 0; x < 16; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'pixel-cell';
                    cell.style.backgroundColor = pixelData[y][x];
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', () => {
                        pixelData[y][x] = currentColor;
                        renderPixelGrid();
                    });
                    pixelGrid.appendChild(cell);
                }
            }
        }

        document.querySelectorAll('.color-option').forEach(opt => {
            opt.addEventListener('click', () => {
                currentColor = opt.style.backgroundColor;
            });
        });

        document.getElementById('editor-btn').addEventListener('click', () => {
            pixelEditor.style.display = 'block';
            controls.unlock();
            renderPixelGrid();
        });

        document.getElementById('close-editor-btn').addEventListener('click', () => {
            pixelEditor.style.display = 'none';
            controls.lock();
        });

        document.getElementById('save-pixel-btn').addEventListener('click', () => {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            for (let y = 0; y < 16; y++) {
                for (let x = 0; x < 16; x++) {
                    ctx.fillStyle = pixelData[y][x];
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            blockTypes[3].texture = texture;
            updateHotbar();
            pixelEditor.style.display = 'none';
            controls.lock();
        });

        // --- PeerJS Multiplayer ---
        let peer;
        let conns = [];
        const remotePlayers = new Map();

        try {
            if (typeof Peer !== 'undefined') {
                peer = new Peer();
                peer.on('open', (id) => {
                    document.getElementById('my-id').textContent = id;
                    document.getElementById('status').textContent = 'Conectado (esperando peers)';
                });
                peer.on('connection', (conn) => setupConnection(conn));
                peer.on('error', (err) => {
                    console.warn('PeerJS error:', err);
                    document.getElementById('status').textContent = 'Error PeerJS, modo local';
                });
            } else {
                document.getElementById('my-id').textContent = 'N/A';
            }
        } catch (e) {
            document.getElementById('my-id').textContent = 'N/A';
        }

        function setupConnection(conn) {
            conns.push(conn);
            document.getElementById('status').textContent = `Conectado a ${conn.peer}`;
            
            conn.on('data', (data) => {
                if (data.type === 'break') {
                    removeBlock(data.x, data.y, data.z);
                } else if (data.type === 'place') {
                    addBlock(data.x, data.y, data.z, data.blockType);
                } else if (data.type === 'position') {
                    let playerMesh = remotePlayers.get(conn.peer);
                    if (!playerMesh) {
                        const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
                        const material = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
                        playerMesh = new THREE.Mesh(geometry, material);
                        scene.add(playerMesh);
                        remotePlayers.set(conn.peer, playerMesh);
                    }
                    playerMesh.position.set(data.x, data.y, data.z);
                }
            });

            conn.on('close', () => {
                conns = conns.filter(c => c !== conn);
                if (remotePlayers.has(conn.peer)) {
                    scene.remove(remotePlayers.get(conn.peer));
                    remotePlayers.delete(conn.peer);
                }
            });
        }

        document.getElementById('connect-btn').addEventListener('click', () => {
            const peerId = document.getElementById('peer-id-input').value;
            if (peerId && peer) {
                const conn = peer.connect(peerId);
                conn.on('open', () => setupConnection(conn));
            } else {
                alert('PeerJS no disponible o ID vacío');
            }
        });

        function sendToAll(data) {
            conns.forEach(conn => conn.send(data));
        }

        setInterval(() => {
            if (conns.length > 0) {
                const pos = controls.getObject().position;
                sendToAll({ type: 'position', x: pos.x, y: pos.y, z: pos.z });
            }
        }, 100);

        // --- Bucle de animación con física y colisiones ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = Math.min(clock.getDelta(), 0.1); // seguridad

            if (controls.isLocked) {
                // Movimiento horizontal (WASD)
                const moveX = (moveState.d ? 1 : 0) - (moveState.a ? 1 : 0);
                const moveZ = (moveState.s ? 1 : 0) - (moveState.w ? 1 : 0);
                
                if (moveX !== 0 || moveZ !== 0) {
                    const angle = camera.rotation.y;
                    const speed = walkSpeed * delta;
                    
                    const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                    const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                    
                    const moveDir = new THREE.Vector3();
                    if (moveZ !== 0) moveDir.add(forward.multiplyScalar(moveZ));
                    if (moveX !== 0) moveDir.add(right.multiplyScalar(moveX));
                    moveDir.normalize();
                    
                    // Intentar mover en X y Z por separado para colisiones
                    const oldPos = controls.getObject().position.clone();
                    
                    // Movimiento en X
                    let newPosX = oldPos.x + moveDir.x * speed;
                    controls.getObject().position.x = newPosX;
                    if (collidesWithWorld(controls.getObject().position)) {
                        controls.getObject().position.x = oldPos.x;
                    }
                    
                    // Movimiento en Z
                    let newPosZ = oldPos.z + moveDir.z * speed;
                    controls.getObject().position.z = newPosZ;
                    if (collidesWithWorld(controls.getObject().position)) {
                        controls.getObject().position.z = oldPos.z;
                    }
                }

                // Gravedad y salto
                velocity.y += gravity * delta;
                
                // Intentar movimiento vertical
                const oldY = controls.getObject().position.y;
                let newY = oldY + velocity.y * delta;
                controls.getObject().position.y = newY;
                
                if (collidesWithWorld(controls.getObject().position)) {
                    // Colisión vertical: ajustar posición y detener velocidad
                    if (velocity.y < 0) {
                        // Cayendo: colocar justo encima del bloque
                        // Buscar el bloque superior
                        const feetY = controls.getObject().position.y - playerHeight/2;
                        const blockY = Math.floor(feetY);
                        // Queremos que los pies estén en blockY + 1 (encima del bloque)
                        controls.getObject().position.y = blockY + 1 + playerHeight/2;
                        velocity.y = 0;
                        onGround = true;
                    } else if (velocity.y > 0) {
                        // Saltando y choca cabeza
                        const headY = controls.getObject().position.y + playerHeight/2;
                        const blockY = Math.ceil(headY);
                        controls.getObject().position.y = blockY - 1 - playerHeight/2;
                        velocity.y = 0;
                    }
                } else {
                    onGround = false;
                }

                // Salto (solo si en el suelo)
                if (moveState.space && onGround) {
                    velocity.y = jumpSpeed;
                    onGround = false;
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
