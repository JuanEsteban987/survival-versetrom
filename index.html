<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft 3D P2P ¬∑ Demo simple</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 10;
            backdrop-filter: blur(5px);
            border: 1px solid #4CAF50;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.9);
            color: #eee;
            padding: 15px 30px;
            border-radius: 50px;
            display: flex;
            gap: 15px;
            z-index: 20;
            backdrop-filter: blur(4px);
            border: 1px solid #888;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #2c3e50;
            color: white;
            letter-spacing: 0.5px;
            border: 1px solid #5f6b7a;
        }
        button:hover {
            background: #34495e;
            transform: scale(1.02);
        }
        button#crearBtn {
            background: #27ae60;
            border-color: #2ecc71;
        }
        button#crearBtn:hover {
            background: #2ecc71;
        }
        button#unirseBtn {
            background: #2980b9;
            border-color: #3498db;
        }
        button#unirseBtn:hover {
            background: #3498db;
        }
        button#desconectarBtn {
            background: #c0392b;
            border-color: #e74c3c;
        }
        button#desconectarBtn:hover {
            background: #e74c3c;
        }
        #estado {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: monospace;
            font-size: 14px;
            z-index: 15;
            border: 1px solid #00ff8040;
            backdrop-filter: blur(3px);
        }
        #peerIdDisplay {
            color: #ffaa00;
            font-weight: bold;
        }
        input {
            padding: 8px 12px;
            border-radius: 20px;
            border: none;
            background: #333;
            color: white;
            margin-right: 8px;
            width: 180px;
        }
        .conectado {
            color: #4CAF50;
        }
        .desconectado {
            color: #f44336;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>‚ö° Minecraft 3D ¬∑ P2P ‚ö°</h2>
        <p>WASD = mover | Mouse = mirar | Click para bloquear cursor | ESC = liberar</p>
        <p>Mundo est√°tico con √°rboles. Otros jugadores = cubo naranja.</p>
    </div>
    <div id="estado">
        üîå Estado: <span id="estadoTexto" class="desconectado">Desconectado</span><br>
        üÜî Mi ID: <span id="miPeerId">-</span><br>
        üë• Conectado a: <span id="conectadoA">-</span>
    </div>
    <div id="controls">
        <button id="crearBtn">üéÆ Crear sala (Host)</button>
        <button id="unirseBtn">üîó Unirse a sala</button>
        <button id="desconectarBtn" disabled>‚õî Desconectar</button>
        <span style="margin-left: 10px; color: #aaa;">|</span>
        <input type="text" id="peerIdInput" placeholder="ID del host para unirse" />
    </div>

    <!-- Importar PeerJS (proporciona peer global) -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    
    <!-- Import map para Three.js y addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // ----- Configuraci√≥n b√°sica de Three.js -----
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Escena, c√°mara, renderizador
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Cielo celeste

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); // Posici√≥n inicial

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Sombras para m√°s realismo
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Luces
        // Luz ambiental
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);

        // Luz solar direccional
        const sunLight = new THREE.DirectionalLight(0xfff5d1, 1.2);
        sunLight.position.set(10, 20, 5);
        sunLight.castShadow = true;
        sunLight.receiveShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        const d = 30;
        sunLight.shadow.camera.left = -d;
        sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d;
        sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 50;
        scene.add(sunLight);

        // Control de primera persona
        const controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject()); // El objeto de controles es el que movemos

        // Bloquear cursor al hacer clic en el canvas
        renderer.domElement.addEventListener('click', () => {
            controls.lock();
        });

        // Variables de movimiento
        const moveState = { forward: false, backward: false, left: false, right: false };
        const velocity = new THREE.Vector3();
        const speed = 5.0;

        // Eventos de teclado
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyD': moveState.right = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyD': moveState.right = false; break;
            }
        });

        // ----- Crear mundo est√°tico (estilo Minecraft b√°sico) -----
        
        // Suelo de hierba
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x3c9e3c });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.01;
        ground.receiveShadow = true;
        scene.add(ground);

        // Rejilla decorativa
        const gridHelper = new THREE.GridHelper(50, 20, 0x888888, 0x444444);
        gridHelper.position.y = 0;
        scene.add(gridHelper);

        // √Årboles / bloques decorativos (simples cubos verdes y marrones)
        function crearArbol(x, z) {
            // Tronco
            const troncoGeo = new THREE.BoxGeometry(0.8, 2, 0.8);
            const troncoMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const tronco = new THREE.Mesh(troncoGeo, troncoMat);
            tronco.position.set(x, 1, z);
            tronco.castShadow = true;
            tronco.receiveShadow = true;
            scene.add(tronco);

            // Hojas (copa simple)
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    for (let k = 0; k < 2; k++) {
                        const hojaGeo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                        const hojaMat = new THREE.MeshStandardMaterial({ color: 0x2e8b57 });
                        const hoja = new THREE.Mesh(hojaGeo, hojaMat);
                        hoja.position.set(x - 1 + i, 2.5 + k, z - 1 + j);
                        hoja.castShadow = true;
                        hoja.receiveShadow = true;
                        scene.add(hoja);
                    }
                }
            }
        }

        // Crear algunos √°rboles aleatorios
        const posiciones = [
            [-5, -5], [5, 5], [-6, 4], [7, -3], [0, -8], [8, 8], [-8, 0], [3, -7]
        ];
        posiciones.forEach(pos => crearArbol(pos[0], pos[1]));

        // Algunos bloques sueltos (piedra, tierra)
        const bloquesSueltos = [
            { color: 0x808080, pos: [2, 0.5, 2] },   // piedra
            { color: 0x654321, pos: [-2, 0.5, -3] }, // tierra
            { color: 0x808080, pos: [4, 0.5, -4] },
            { color: 0x654321, pos: [-5, 0.5, 5] },
        ];
        bloquesSueltos.forEach(b => {
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshStandardMaterial({ color: b.color });
            const cube = new THREE.Mesh(geo, mat);
            cube.position.set(b.pos[0], b.pos[1], b.pos[2]);
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
        });

        // Peque√±as flores/vegetaci√≥n (cubos peque√±os de colores)
        for (let i = 0; i < 20; i++) {
            const x = (Math.random() - 0.5) * 40;
            const z = (Math.random() - 0.5) * 40;
            if (Math.abs(x) < 2 && Math.abs(z) < 2) continue; // evitar centro
            const florGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const florMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
            const flor = new THREE.Mesh(florGeo, florMat);
            flor.position.set(x, 0.15, z);
            flor.castShadow = true;
            flor.receiveShadow = true;
            scene.add(flor);
        }

        // ----- L√≥gica P2P con PeerJS -----
        let peer = null;
        let conn = null; // conexi√≥n activa
        let remotePlayerMesh = null; // malla del otro jugador
        let miId = null;

        // Elementos UI
        const estadoTexto = document.getElementById('estadoTexto');
        const miPeerSpan = document.getElementById('miPeerId');
        const conectadoASpan = document.getElementById('conectadoA');
        const crearBtn = document.getElementById('crearBtn');
        const unirseBtn = document.getElementById('unirseBtn');
        const desconectarBtn = document.getElementById('desconectarBtn');
        const peerIdInput = document.getElementById('peerIdInput');

        // Actualizar UI seg√∫n estado de conexi√≥n
        function actualizarUI(conectado, peerIdRemoto = null) {
            if (conectado) {
                estadoTexto.innerText = 'Conectado';
                estadoTexto.className = 'conectado';
                conectadoASpan.innerText = peerIdRemoto || '?';
                desconectarBtn.disabled = false;
                crearBtn.disabled = true;
                unirseBtn.disabled = true;
            } else {
                estadoTexto.innerText = 'Desconectado';
                estadoTexto.className = 'desconectado';
                conectadoASpan.innerText = '-';
                desconectarBtn.disabled = true;
                crearBtn.disabled = false;
                unirseBtn.disabled = false;
                // Eliminar malla remota si existe
                if (remotePlayerMesh) {
                    scene.remove(remotePlayerMesh);
                    remotePlayerMesh = null;
                }
            }
        }

        // Crear malla para el jugador remoto (un cubo naranja con una "cara" blanca para indicar direcci√≥n)
        function crearJugadorRemoto() {
            const grupo = new THREE.Group();
            
            // Cuerpo principal
            const cuerpoGeo = new THREE.BoxGeometry(1, 2, 1);
            const cuerpoMat = new THREE.MeshStandardMaterial({ color: 0xff6600 });
            const cuerpo = new THREE.Mesh(cuerpoGeo, cuerpoMat);
            cuerpo.position.y = 1;
            cuerpo.castShadow = true;
            cuerpo.receiveShadow = true;
            grupo.add(cuerpo);

            // "Cara" para indicar frente (blanco)
            const caraGeo = new THREE.BoxGeometry(0.3, 0.3, 0.1);
            const caraMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const cara = new THREE.Mesh(caraGeo, caraMat);
            cara.position.set(0, 1.2, 0.51); // ligeramente adelante
            grupo.add(cara);

            // Ojos negros
            const ojoGeo = new THREE.BoxGeometry(0.15, 0.15, 0.1);
            const ojoMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const ojoIzq = new THREE.Mesh(ojoGeo, ojoMat);
            ojoIzq.position.set(-0.25, 1.3, 0.56);
            grupo.add(ojoIzq);
            const ojoDer = new THREE.Mesh(ojoGeo, ojoMat);
            ojoDer.position.set(0.25, 1.3, 0.56);
            grupo.add(ojoDer);

            return grupo;
        }

        // Enviar posici√≥n y rotaci√≥n locales al otro peer
        function enviarEstado() {
            if (conn && conn.open) {
                const pos = controls.getObject().position;
                // La rotaci√≥n: yaw (rotaci√≥n en Y) del objeto controls
                const rot = controls.getObject().rotation;
                conn.send({
                    type: 'playerUpdate',
                    x: pos.x,
                    y: pos.y,
                    z: pos.z,
                    ry: rot.y // solo necesitamos rotaci√≥n horizontal
                });
            }
        }

        // Bucle de movimiento y env√≠o de datos
        const clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            
            // Movimiento del jugador local (solo cuando el cursor est√° bloqueado)
            if (controls.isLocked) {
                velocity.x = 0;
                velocity.z = 0;
                if (moveState.forward) velocity.z = -speed * delta;
                if (moveState.backward) velocity.z = speed * delta;
                if (moveState.left) velocity.x = -speed * delta;
                if (moveState.right) velocity.x = speed * delta;
                
                controls.moveRight(velocity.x);
                controls.moveForward(velocity.z);
                
                // Mantener altura constante (opcional, pero el terreno es plano)
                const pos = controls.getObject().position;
                pos.y = 2; // fijar altura para no caer
            }

            // Enviar actualizaci√≥n a peer conectado (m√°x 10 veces/segundo, pero lo hacemos cada frame, controlado por tiempo)
            // Para no saturar, usamos un throttling simple
            if (conn && conn.open) {
                // Enviar cada 100ms aprox (10 fps)
                if (Math.random() < 0.1) { // forma cutre de throttling, pero funciona
                    enviarEstado();
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        // Ajustar ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ----- Eventos de PeerJS -----
        crearBtn.addEventListener('click', () => {
            if (peer) peer.destroy();
            
            // Crear nuevo peer con ID aleatorio
            peer = new Peer(); 
            
            peer.on('open', (id) => {
                miId = id;
                miPeerSpan.innerText = id;
                estadoTexto.innerText = 'Esperando conexi√≥n...';
                estadoTexto.className = '';
                console.log('Mi peer ID:', id);
            });

            peer.on('connection', (connection) => {
                conn = connection;
                conn.on('open', () => {
                    console.log('Conectado a:', conn.peer);
                    actualizarUI(true, conn.peer);
                    
                    // Crear malla para el remoto si no existe
                    if (!remotePlayerMesh) {
                        remotePlayerMesh = crearJugadorRemoto();
                        scene.add(remotePlayerMesh);
                    }

                    // Recibir datos
                    conn.on('data', (data) => {
                        if (data.type === 'playerUpdate' && remotePlayerMesh) {
                            remotePlayerMesh.position.set(data.x, data.y, data.z);
                            remotePlayerMesh.rotation.y = data.ry;
                        }
                    });
                });

                conn.on('close', () => {
                    actualizarUI(false);
                    conn = null;
                });
            });

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                alert('Error de Peer: ' + err.type);
            });
        });

        unirseBtn.addEventListener('click', () => {
            const remoteId = peerIdInput.value.trim();
            if (!remoteId) {
                alert('Ingresa un ID de host v√°lido');
                return;
            }
            if (!peer) {
                // Crear peer si no existe
                peer = new Peer();
                peer.on('open', (id) => {
                    miId = id;
                    miPeerSpan.innerText = id;
                    conectar(remoteId);
                });
            } else {
                conectar(remoteId);
            }
        });

        function conectar(remoteId) {
            if (!peer) return;
            const connection = peer.connect(remoteId);
            connection.on('open', () => {
                conn = connection;
                actualizarUI(true, remoteId);
                
                if (!remotePlayerMesh) {
                    remotePlayerMesh = crearJugadorRemoto();
                    scene.add(remotePlayerMesh);
                }

                connection.on('data', (data) => {
                    if (data.type === 'playerUpdate' && remotePlayerMesh) {
                        remotePlayerMesh.position.set(data.x, data.y, data.z);
                        remotePlayerMesh.rotation.y = data.ry;
                    }
                });

                connection.on('close', () => {
                    actualizarUI(false);
                    conn = null;
                });
            });
            connection.on('error', (err) => {
                console.error('Connection error:', err);
                alert('No se pudo conectar al peer');
            });
        }

        desconectarBtn.addEventListener('click', () => {
            if (conn) {
                conn.close();
                conn = null;
            }
            actualizarUI(false);
        });

        // Inicializar UI
        actualizarUI(false);

        // Nota: Para que funcione correctamente, el peer anfitri√≥n debe compartir su ID que aparece en "Mi ID"
        // y el otro debe ingresarlo en el campo y presionar "Unirse a sala".
        // La comunicaci√≥n es uno a uno.
    </script>
</body>
</html>
