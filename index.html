<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft P2P Pixel Art</title>
    <style>
        /* mismos estilos */
        body { margin: 0; overflow: hidden; font-family: 'Courier New', monospace; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 100;
            pointer-events: none;
        }
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
            z-index: 200;
            pointer-events: auto;
        }
        .slot {
            width: 60px;
            height: 60px;
            background: #8b8b8b;
            border: 3px solid #555;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            text-shadow: 1px 1px 0 #000;
            font-size: 12px;
            transition: 0.2s;
            image-rendering: pixelated;
        }
        .slot.selected {
            border-color: #ffaa00;
            transform: scale(1.1);
        }
        .slot canvas {
            width: 40px;
            height: 40px;
            image-rendering: pixelated;
        }
        #pixel-editor {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #333;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #fff;
            z-index: 300;
            display: none;
            color: white;
            text-align: center;
        }
        #pixel-grid {
            display: grid;
            grid-template-columns: repeat(16, 20px);
            gap: 1px;
            margin: 10px 0;
            background: #222;
            padding: 5px;
        }
        .pixel-cell {
            width: 20px;
            height: 20px;
            background: #fff;
            cursor: pointer;
            image-rendering: pixelated;
        }
        #color-palette {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin: 10px 0;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid #fff;
        }
        #peer-section {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
        }
        #peer-section input, #peer-section button {
            padding: 5px;
            font-family: inherit;
        }
        #status {
            color: #0f0;
            font-size: 12px;
        }
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 8px 12px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: #45a049;
        }
    </style>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
    <div id="info">
        <div>Romper: Click izquierdo | Poner: Click derecho</div>
        <div>Movimiento: WASD | Mirar: Mouse</div>
        <div>Pixel art: Botón "Editor"</div>
    </div>
    <div id="controls">Bloque seleccionado: <span id="selected-block-name">Grass</span></div>
    <div id="hotbar"></div>
    <div id="peer-section">
        <div>Mi ID: <span id="my-id">conectando...</span></div>
        <input type="text" id="peer-id-input" placeholder="ID del peer">
        <button id="connect-btn">Conectar</button>
        <button id="editor-btn">Editor Pixel Art</button>
        <div id="status">Desconectado</div>
    </div>
    <div id="pixel-editor">
        <h3>Editor 16x16</h3>
        <div id="pixel-grid"></div>
        <div id="color-palette">
            <div class="color-option" style="background:#8B4513;"></div>
            <div class="color-option" style="background:#654321;"></div>
            <div class="color-option" style="background:#228B22;"></div>
            <div class="color-option" style="background:#FF0000;"></div>
            <div class="color-option" style="background:#0000FF;"></div>
            <div class="color-option" style="background:#FFFF00;"></div>
        </div>
        <div>
            <button id="save-pixel-btn">Guardar como bloque</button>
            <button id="close-editor-btn">Cerrar</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'https://unpkg.com/three@0.128.0/examples/jsm/controls/PointerLockControls.js';

        const Peer = window.Peer;

        // --- Configuración inicial ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Luces
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
        backLight.position.set(-1, 0.5, -1);
        scene.add(backLight);

        // Controles primera persona
        const controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        renderer.domElement.addEventListener('click', () => {
            if (!controls.isLocked) controls.lock();
        });

        // Variables de movimiento
        const moveState = { w: false, a: false, s: false, d: false };
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const speed = 2.0; // Reducido de 5 a 2 para movimiento más lento

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.w = true; break;
                case 'KeyA': moveState.a = true; break;
                case 'KeyS': moveState.s = true; break;
                case 'KeyD': moveState.d = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.w = false; break;
                case 'KeyA': moveState.a = false; break;
                case 'KeyS': moveState.s = false; break;
                case 'KeyD': moveState.d = false; break;
            }
        });

        // --- Mundo de bloques ---
        const blockSize = 1;
        const blocks = new Map(); // clave "x,y,z" -> { type, mesh }

        function createPixelTexture(colors) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            for (let y = 0; y < 16; y++) {
                for (let x = 0; x < 16; x++) {
                    ctx.fillStyle = colors[y][x] || '#8B4513';
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            return new THREE.CanvasTexture(canvas);
        }

        function grassTexture() {
            const colors = Array(16).fill().map(() => Array(16).fill('#228B22'));
            for (let i = 0; i < 20; i++) {
                colors[Math.floor(Math.random()*16)][Math.floor(Math.random()*16)] = '#8B4513';
            }
            return createPixelTexture(colors);
        }

        function dirtTexture() {
            const colors = Array(16).fill().map(() => Array(16).fill('#8B4513'));
            return createPixelTexture(colors);
        }

        function stoneTexture() {
            const colors = Array(16).fill().map(() => Array(16).fill('#808080'));
            for (let i = 0; i < 30; i++) {
                colors[Math.floor(Math.random()*16)][Math.floor(Math.random()*16)] = '#A9A9A9';
            }
            return createPixelTexture(colors);
        }

        const blockTypes = [
            { name: 'Grass', texture: grassTexture() },
            { name: 'Dirt', texture: dirtTexture() },
            { name: 'Stone', texture: stoneTexture() },
            { name: 'Custom', texture: grassTexture() }
        ];

        let inventory = [0, 1, 2, 3];
        let selectedSlot = 0;

        const hotbarDiv = document.getElementById('hotbar');
        function updateHotbar() {
            hotbarDiv.innerHTML = '';
            inventory.forEach((typeIdx, i) => {
                const slot = document.createElement('div');
                slot.className = 'slot' + (i === selectedSlot ? ' selected' : '');
                const canvas = document.createElement('canvas');
                canvas.width = 16;
                canvas.height = 16;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                const texture = blockTypes[typeIdx].texture;
                ctx.drawImage(texture.image, 0, 0, 16, 16);
                slot.appendChild(canvas);
                const span = document.createElement('span');
                span.textContent = blockTypes[typeIdx].name;
                slot.appendChild(span);
                slot.addEventListener('click', () => {
                    selectedSlot = i;
                    updateHotbar();
                    document.getElementById('selected-block-name').textContent = blockTypes[inventory[selectedSlot]].name;
                });
                hotbarDiv.appendChild(slot);
            });
        }
        updateHotbar();
        document.getElementById('selected-block-name').textContent = blockTypes[inventory[selectedSlot]].name;

        function addBlock(x, y, z, typeIndex) {
            const key = `${x},${y},${z}`;
            if (blocks.has(key)) return;
            
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const materials = [
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture }),
                new THREE.MeshStandardMaterial({ map: blockTypes[typeIndex].texture })
            ];
            const cube = new THREE.Mesh(geometry, materials);
            cube.position.set(x, y, z);
            scene.add(cube);
            blocks.set(key, { type: typeIndex, mesh: cube });
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = blocks.get(key);
            if (block) {
                scene.remove(block.mesh);
                block.mesh.geometry.dispose();
                block.mesh.material.forEach(m => m.dispose());
                blocks.delete(key);
                return true;
            }
            return false;
        }

        // Suelo inicial
        for (let x = -5; x < 5; x++) {
            for (let z = -5; z < 5; z++) {
                addBlock(x, 0, z, 0);
            }
        }
        addBlock(2, 1, 2, 1);
        addBlock(2, 2, 2, 2);
        addBlock(-2, 1, -2, 0);

        // --- Colisiones ---
        // Tamaño del jugador (aproximado)
        const playerHeight = 1.8;
        const playerWidth = 0.6;
        const playerDepth = 0.6;

        function getPlayerBoundingBox(pos) {
            // pos es la posición de la cámara (ojos), el centro del cuerpo está en pos.y - playerHeight/2
            const min = new THREE.Vector3(
                pos.x - playerWidth/2,
                pos.y - playerHeight,
                pos.z - playerDepth/2
            );
            const max = new THREE.Vector3(
                pos.x + playerWidth/2,
                pos.y,
                pos.z + playerDepth/2
            );
            return { min, max };
        }

        function checkCollision(newPos) {
            const box = getPlayerBoundingBox(newPos);
            // Iterar sobre todos los bloques
            for (let [key, block] of blocks) {
                const blockPos = block.mesh.position;
                // AABB collision
                if (box.max.x > blockPos.x - 0.5 && box.min.x < blockPos.x + 0.5 &&
                    box.max.y > blockPos.y - 0.5 && box.min.y < blockPos.y + 0.5 &&
                    box.max.z > blockPos.z - 0.5 && box.min.z < blockPos.z + 0.5) {
                    return true; // hay colisión
                }
            }
            return false;
        }

        // --- Raycaster ---
        const raycaster = new THREE.Raycaster();

        function getBlockAtCursor() {
            if (!controls.isLocked) return null;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(Array.from(blocks.values()).map(b => b.mesh));
            if (intersects.length > 0) {
                const hit = intersects[0];
                const pos = hit.object.position;
                return { 
                    pos, 
                    face: hit.face.normal,
                    block: blocks.get(`${pos.x},${pos.y},${pos.z}`)
                };
            }
            return null;
        }

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (!controls.isLocked) return;
            e.preventDefault();
            const hit = getBlockAtCursor();
            if (!hit) return;

            if (e.button === 0) { // izquierdo
                removeBlock(hit.pos.x, hit.pos.y, hit.pos.z);
                sendToAll({ type: 'break', x: hit.pos.x, y: hit.pos.y, z: hit.pos.z });
            } else if (e.button === 2) { // derecho
                e.preventDefault();
                const normal = hit.face;
                const newPos = hit.pos.clone().add(normal);
                if (!blocks.has(`${newPos.x},${newPos.y},${newPos.z}`)) {
                    const typeIdx = inventory[selectedSlot];
                    addBlock(newPos.x, newPos.y, newPos.z, typeIdx);
                    sendToAll({ type: 'place', x: newPos.x, y: newPos.y, z: newPos.z, blockType: typeIdx });
                }
            }
        });

        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Pixel Editor ---
        const pixelEditor = document.getElementById('pixel-editor');
        const pixelGrid = document.getElementById('pixel-grid');
        let currentColor = '#8B4513';
        let pixelData = Array(16).fill().map(() => Array(16).fill('#FFFFFF'));

        function renderPixelGrid() {
            pixelGrid.innerHTML = '';
            for (let y = 0; y < 16; y++) {
                for (let x = 0; x < 16; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'pixel-cell';
                    cell.style.backgroundColor = pixelData[y][x];
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', () => {
                        pixelData[y][x] = currentColor;
                        renderPixelGrid();
                    });
                    pixelGrid.appendChild(cell);
                }
            }
        }

        document.querySelectorAll('.color-option').forEach(opt => {
            opt.addEventListener('click', () => {
                currentColor = opt.style.backgroundColor;
            });
        });

        document.getElementById('editor-btn').addEventListener('click', () => {
            pixelEditor.style.display = 'block';
            controls.unlock();
            renderPixelGrid();
        });

        document.getElementById('close-editor-btn').addEventListener('click', () => {
            pixelEditor.style.display = 'none';
            controls.lock();
        });

        document.getElementById('save-pixel-btn').addEventListener('click', () => {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            for (let y = 0; y < 16; y++) {
                for (let x = 0; x < 16; x++) {
                    ctx.fillStyle = pixelData[y][x];
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            blockTypes[3].texture = texture;
            updateHotbar();
            pixelEditor.style.display = 'none';
            controls.lock();
        });

        // --- Multiplayer ---
        let peer;
        let conns = [];
        const remotePlayers = new Map();

        try {
            if (typeof Peer !== 'undefined') {
                peer = new Peer();
                peer.on('open', (id) => {
                    document.getElementById('my-id').textContent = id;
                    document.getElementById('status').textContent = 'Conectado (esperando peers)';
                });
                peer.on('connection', (conn) => {
                    setupConnection(conn);
                });
                peer.on('error', (err) => {
                    console.warn('PeerJS error:', err);
                    document.getElementById('status').textContent = 'Error PeerJS, modo local';
                });
            } else {
                console.warn('PeerJS no disponible');
                document.getElementById('my-id').textContent = 'N/A';
            }
        } catch (e) {
            console.warn('PeerJS error:', e);
        }

        function setupConnection(conn) {
            conns.push(conn);
            document.getElementById('status').textContent = `Conectado a ${conn.peer}`;
            
            conn.on('data', (data) => {
                if (data.type === 'break') {
                    removeBlock(data.x, data.y, data.z);
                } else if (data.type === 'place') {
                    addBlock(data.x, data.y, data.z, data.blockType);
                } else if (data.type === 'position') {
                    let playerMesh = remotePlayers.get(conn.peer);
                    if (!playerMesh) {
                        const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
                        const material = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
                        playerMesh = new THREE.Mesh(geometry, material);
                        scene.add(playerMesh);
                        remotePlayers.set(conn.peer, playerMesh);
                    }
                    playerMesh.position.set(data.x, data.y, data.z);
                }
            });

            conn.on('close', () => {
                conns = conns.filter(c => c !== conn);
                if (remotePlayers.has(conn.peer)) {
                    scene.remove(remotePlayers.get(conn.peer));
                    remotePlayers.delete(conn.peer);
                }
            });
        }

        document.getElementById('connect-btn').addEventListener('click', () => {
            const peerId = document.getElementById('peer-id-input').value;
            if (peerId && peer) {
                const conn = peer.connect(peerId);
                conn.on('open', () => {
                    setupConnection(conn);
                });
            } else {
                alert('PeerJS no inicializado o ID vacío');
            }
        });

        function sendToAll(data) {
            conns.forEach(conn => conn.send(data));
        }

        setInterval(() => {
            if (conns.length > 0) {
                const pos = controls.getObject().position;
                sendToAll({ type: 'position', x: pos.x, y: pos.y, z: pos.z });
            }
        }, 100);

        // --- Bucle de animación con física y colisiones ---
        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked) {
                // Aplicar fricción
                velocity.x *= 0.9;
                velocity.z *= 0.9;
                
                // Calcular dirección deseada
                direction.z = Number(moveState.w) - Number(moveState.s);
                direction.x = Number(moveState.d) - Number(moveState.a);
                direction.normalize();
                
                // Aceleración
                if (moveState.w || moveState.s) velocity.z += direction.z * speed * 0.05;
                if (moveState.a || moveState.d) velocity.x += direction.x * speed * 0.05;
                
                // Intentar movimiento en X
                let newPos = controls.getObject().position.clone();
                newPos.x += velocity.x;
                if (!checkCollision(newPos)) {
                    controls.getObject().position.x = newPos.x;
                } else {
                    velocity.x = 0;
                }
                
                // Intentar movimiento en Z
                newPos = controls.getObject().position.clone();
                newPos.z += velocity.z;
                if (!checkCollision(newPos)) {
                    controls.getObject().position.z = newPos.z;
                } else {
                    velocity.z = 0;
                }
                
                // Gravedad
                newPos = controls.getObject().position.clone();
                newPos.y -= 0.1; // caída suave
                if (!checkCollision(newPos)) {
                    controls.getObject().position.y = newPos.y;
                } else {
                    // Si choca al caer, nos detenemos
                    velocity.y = 0;
                    // Ajustar para quedar justo encima del bloque?
                    // Por simplicidad, no hacemos ajuste fino
                }

                // Mantener altura mínima (suelo)
                if (controls.getObject().position.y < 1.5) {
                    controls.getObject().position.y = 1.5;
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        console.log('Juego iniciado con colisiones y movimiento lento');
    </script>
</body>
</html>
