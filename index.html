<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minecraft JS: INFINITE CHUNKS EDITION</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noisejs/2.0.2/perlin.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', monospace; background: #87ceeb; user-select: none; touch-action: none; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 20; }
        .full-overlay { position: fixed; inset: 0; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; background: rgba(0,0,0,0.85); pointer-events: auto; }
        .panel { background: #c6c6c6; border: 4px solid #373737; padding: 20px; color: #333; text-align: center; box-shadow: inset -4px -4px #555, inset 4px 4px #fff; }
        .btn { background: #4CAF50; color: white; border: none; padding: 12px; margin: 8px; cursor: pointer; font-weight: bold; border-bottom: 4px solid #2e7d32; width: 220px; }
        .btn-blue { background: #2196F3; border-bottom-color: #0b7ad1; }
        .btn-red { background: #f44336; border-bottom-color: #b71c1c; }
        #hotbar { position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; background: rgba(0,0,0,0.6); padding: 6px; border: 3px solid #555; pointer-events: auto; }
        .h-slot { width: 45px; height: 45px; border: 2px solid #444; display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; }
        .h-slot.active { border-color: #fff; background: rgba(255,255,255,0.2); }
        #mobile-controls { position: fixed; inset: 0; pointer-events: none; display: none; z-index: 50; }
        .m-btn { position: absolute; width: 65px; height: 65px; background: rgba(255,255,255,0.2); border-radius: 12px; pointer-events: auto; display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold; border: 2px solid rgba(255,255,255,0.1); }
        #joystick-zone { position: absolute; bottom: 40px; left: 40px; width: 110px; height: 110px; background: rgba(255,255,255,0.1); border-radius: 50%; pointer-events: auto; }
        #joystick-knob { position: absolute; top: 35px; left: 35px; width: 40px; height: 40px; background: rgba(255,255,255,0.4); border-radius: 50%; }
        #m-jump { bottom: 40px; right: 100px; width: 90px; }
        #m-mine { bottom: 220px; right: 30px; background: rgba(255,0,0,0.3); }
        #m-place { bottom: 140px; right: 110px; background: rgba(0,120,255,0.3); }
        #m-inv { top: 15px; left: 15px; background: #4CAF50; }
        #m-srv { top: 15px; right: 15px; background: #2196F3; }
        #stats { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: white; font-size: 12px; text-shadow: 1px 1px #000; pointer-events: none; }
    </style>
</head>
<body>
    <div id="stats">Chunks cargados: 0</div>
    
    <div id="main-menu" class="full-overlay" style="display: flex;">
        <div class="panel">
            <h1>INFINITE JS CRAFT</h1>
            <button class="btn" onclick="start(false)">MODO PC</button>
            <button class="btn" onclick="start(true)">MODO MÓVIL</button>
        </div>
    </div>

    <div id="srv-panel" class="full-overlay">
        <div class="panel">
            <h2>MULTIPLAYER P2P</h2>
            <p id="srv-id">ID: Generando...</p>
            <button class="btn btn-blue" onclick="hostSrv()">HOSTEAR</button>
            <input type="text" id="join-id" placeholder="ID del Host..." style="padding:10px; margin:5px;"><br>
            <button class="btn" onclick="joinSrv()">UNIRSE</button><br>
            <button class="btn btn-red" onclick="closeAll()">CERRAR</button>
        </div>
    </div>

    <div id="inv-panel" class="full-overlay">
        <div class="panel">
            <h2>INVENTARIO / CRAFTEO</h2>
            <div id="inv-list" style="display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-bottom:15px;"></div>
            <button class="btn btn-blue" onclick="alert('Crafteo: 4 Madera -> 1 Mesa')">CRAFTEAR</button>
            <button class="btn btn-red" onclick="closeAll()">CERRAR</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div class="m-btn" id="m-mine">MINAR</div>
        <div class="m-btn" id="m-place">PONER</div>
        <div class="m-btn" id="m-jump">SALTAR</div>
        <div class="m-btn" id="m-inv">INV</div>
        <div class="m-btn" id="m-srv">SRV</div>
    </div>

    <div id="ui-layer">
        <div id="hotbar">
            <div class="h-slot active" id="s0">Pasto</div>
            <div class="h-slot" id="s1">Tierra</div>
            <div class="h-slot" id="s2">Piedra</div>
            <div class="h-slot" id="s3">Madera</div>
            <div class="h-slot" id="s4">Mesa</div>
        </div>
    </div>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }</script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

        // --- CONFIGURACIÓN DE CHUNKS ---
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 2; // Chunks a la redonda
        const chunks = new Map();
        let currentChunk = { x: 0, z: 0 };

        // --- ESTADO DEL JUEGO ---
        let scene, camera, renderer, controls, clock;
        let isMobile = false, activeSlot = 0, velocityY = 0, isGrounded = false;
        let keys = {}, inventory = [64, 0, 0, 0, 0];
        const colors = [0x567d46, 0x8b5a2b, 0x808080, 0x654321, 0xdeb887];
        
        // Multiplayer
        let peer, conn, remotePlayers = {};

        window.start = (mobile) => {
            isMobile = mobile;
            document.getElementById('main-menu').style.display = 'none';
            if(isMobile) document.getElementById('mobile-controls').style.display = 'block';
            
            initThree();
            noise.seed(Math.random());
            updateChunks();
            animate();
        };

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, CHUNK_SIZE * RENDER_DISTANCE * 1.5);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(8, 10, 8);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            clock = new THREE.Clock();

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const sun = new THREE.DirectionalLight(0xffffff, 0.5);
            sun.position.set(10, 50, 10);
            scene.add(sun);
        }

        // --- MOTOR DE CHUNKS INFINITO ---
        function updateChunks() {
            const cx = Math.floor(camera.position.x / CHUNK_SIZE);
            const cz = Math.floor(camera.position.z / CHUNK_SIZE);

            if (cx !== currentChunk.x || cz !== currentChunk.z) {
                currentChunk = { x: cx, z: cz };
                
                // Generar nuevos chunks dentro del rango
                for (let x = cx - RENDER_DISTANCE; x <= cx + RENDER_DISTANCE; x++) {
                    for (let z = cz - RENDER_DISTANCE; z <= cz + RENDER_DISTANCE; z++) {
                        const key = `${x},${z}`;
                        if (!chunks.has(key)) {
                            generateChunk(x, z);
                        }
                    }
                }

                // Limpiar chunks lejanos para ahorrar memoria
                for (const [key, chunk] of chunks) {
                    const [kx, kz] = key.split(',').map(Number);
                    if (Math.abs(kx - cx) > RENDER_DISTANCE + 1 || Math.abs(kz - cz) > RENDER_DISTANCE + 1) {
                        chunk.forEach(b => { scene.remove(b); b.geometry.dispose(); b.material.dispose(); });
                        chunks.delete(key);
                    }
                }
                document.getElementById('stats').innerText = `Chunks cargados: ${chunks.size} | Pos: ${Math.round(camera.position.x)}, ${Math.round(camera.position.z)}`;
            }
        }

        function generateChunk(cx, cz) {
            const chunkBlocks = [];
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const worldX = cx * CHUNK_SIZE + x;
                    const worldZ = cz * CHUNK_SIZE + z;
                    
                    // Ruido Perlin para elevación
                    const h = Math.floor(noise.perlin2(worldX / 20, worldZ / 20) * 5) + 5;

                    // Bloque de superficie
                    chunkBlocks.push(addBlock(worldX, h, worldZ, colors[0]));
                    // Bloque de tierra debajo
                    chunkBlocks.push(addBlock(worldX, h-1, worldZ, colors[1]));
                    // Piedra profunda
                    chunkBlocks.push(addBlock(worldX, h-2, worldZ, colors[2]));
                }
            }
            chunks.set(`${cx},${cz}`, chunkBlocks);
        }

        function addBlock(x, y, z, color) {
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshStandardMaterial({ color })
            );
            mesh.position.set(x, y, z);
            scene.add(mesh);
            return mesh;
        }

        // --- MULTIPLAYER ---
        window.hostSrv = () => {
            peer = new Peer();
            peer.on('open', id => document.getElementById('srv-id').innerText = "ID: " + id);
            peer.on('connection', c => { conn = c; setupConn(); });
        };

        window.joinSrv = () => {
            const id = document.getElementById('join-id').value;
            peer = new Peer();
            peer.on('open', () => { conn = peer.connect(id); setupConn(); });
        };

        function setupConn() {
            conn.on('open', () => {
                closeAll();
                setInterval(() => {
                    conn.send({ type: 'move', x: camera.position.x, y: camera.position.y, z: camera.position.z });
                }, 50);
            });
            conn.on('data', data => {
                if(data.type === 'move') {
                    if(!remotePlayers[conn.peer]) {
                        remotePlayers[conn.peer] = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.8, 0.6), new THREE.MeshBasicMaterial({color: 0xff0000}));
                        scene.add(remotePlayers[conn.peer]);
                    }
                    remotePlayers[conn.peer].position.set(data.x, data.y - 0.8, data.z);
                }
            });
        }

        // --- LOOP PRINCIPAL ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);

            if (controls.isLocked || isMobile) {
                updateChunks();
                velocityY -= 25 * delta;
                
                const move = new THREE.Vector3();
                if (isMobile) { move.z = -joyDir.y; move.x = joyDir.x; }
                else {
                    if(keys['KeyW']) move.z += 1; if(keys['KeyS']) move.z -= 1;
                    if(keys['KeyA']) move.x -= 1; if(keys['KeyD']) move.x += 1;
                }

                const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
                const right = new THREE.Vector3().crossVectors(dir, camera.up);

                camera.position.addScaledVector(dir, move.z * 7 * delta);
                camera.position.addScaledVector(right, move.x * 7 * delta);
                camera.position.y += velocityY * delta;

                // Colisión básica con suelo dinámico
                if(camera.position.y < 12) { // Altura mínima de seguridad
                    camera.position.y = 12; velocityY = 0; isGrounded = true;
                } else { isGrounded = false; }
            }
            renderer.render(scene, camera);
        }

        // --- INPUTS & UI ---
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(e.code === 'Space' && isGrounded) velocityY = 10;
            if(e.key >= 1 && e.key <= 5) setSlot(e.key - 1);
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        function setSlot(i) {
            activeSlot = i;
            document.querySelectorAll('.h-slot').forEach((s, idx) => s.classList.toggle('active', idx === i));
        }

        window.closeAll = () => {
            document.querySelectorAll('.full-overlay').forEach(e => e.style.display = 'none');
            if(!isMobile) controls.lock();
        };

        document.getElementById('m-jump').onclick = () => { if(isGrounded) velocityY = 10; };
        document.getElementById('m-inv').onclick = () => { document.getElementById('inv-panel').style.display = 'flex'; controls.unlock(); };
        document.getElementById('m-srv').onclick = () => { document.getElementById('srv-panel').style.display = 'flex'; controls.unlock(); };

        // Joystick
        let joyDir = {x:0, y:0}, touchX, touchY;
        document.getElementById('joystick-zone').ontouchmove = e => {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = e.touches[0].clientX - (rect.left + 55), y = e.touches[0].clientY - (rect.top + 55);
            const dist = Math.min(Math.sqrt(x*x + y*y), 40), angle = Math.atan2(y, x);
            joyDir = { x: (Math.cos(angle)*dist)/40, y: (Math.sin(angle)*dist)/40 };
            document.getElementById('joystick-knob').style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
        };
        document.getElementById('joystick-zone').ontouchend = () => {
            joyDir = {x:0, y:0}; document.getElementById('joystick-knob').style.transform = 'translate(0,0)';
        };

        // Cámara Táctil (Lado derecho de la pantalla)
        window.addEventListener('touchstart', e => { if(isMobile && e.touches[0].pageX > window.innerWidth/2) { touchX = e.touches[0].pageX; touchY = e.touches[0].pageY; }});
        window.addEventListener('touchmove', e => {
            if(isMobile && e.touches[0].pageX > window.innerWidth/2) {
                camera.rotation.y -= (e.touches[0].pageX - touchX) * 0.006;
                camera.rotation.x -= (e.touches[0].pageY - touchY) * 0.006;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                touchX = e.touches[0].pageX; touchY = e.touches[0].pageY;
            }
        });
    </script>
</body>
</html>
